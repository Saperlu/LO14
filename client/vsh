#!/bin/bash
regexServeur="^[[:alnum:].:]+$"
regexPort="^[[:digit:]]+$"
regexNomArchive="^[[:alnum:]._-]+$"

FIFO="/tmp/fifo-$$-client"
function nettoyage() { rm -f "$FIFO"; }
trap nettoyage EXIT
[ -e "$FIFO" ] || mkfifo "$FIFO"

function printResult () {
    i=0
    n=1
    while [[ $i -ne $n ]]
    do
        while read -r line
        do
            if [[ $i -eq 0 ]]
            then
                n=$line
            else
                echo -e "$line"
            fi
            if [[ $i -eq $n ]]
            then
                kill $!
                break
            fi
            ((i++))
        done < "$FIFO"
    done
}

function list () {
    serveur=$1
    port=$2
    echo list | netcat "$serveur" "$port" > "$FIFO" &
    printResult
    exit 0
}

function create () {
    zip=$(tar -cz ./* | base64)
    serveur=$1
    port=$2
    archive=$3
    echo "create $archive $zip" | netcat "$serveur" "$port" > "$FIFO" &
    i=0
    while :
    do
        while read -r line
        do
            if [[ $i -eq 0 ]]
            then
                n=$line
            elif [[ -n $line ]]
            then
                echo -e "$line"
            fi

            if [[ $i -eq $n ]]
            then
                kill $!
                exit 0
            fi
            ((i++))
        done < "$FIFO"
    done
}

function browse-ls () {
    serveur=$1
    port=$2
    archive=$3
    currentDir=$4
    echo "browse ls arch" | netcat "$serveur" "$port" > "$FIFO" &
    printResult
}

function browse-cd () {
    serveur=$1
    port=$2
    archive=$3
    # currentDir=$4
    dossier=$5
    
    echo "browse cd $archive $currentDir $dossier" | netcat "$serveur" "$port" > "$FIFO" &
    i=0
    n=1
    while [ $i -ne $n ]
    do
        while read -r line
        do
            if [[ $i -eq 0 ]]
            then
                n=$line
            elif [[ $i -eq 1 ]] # Spécifique au cd
            then
                # On remplace les / par des \\ dans la string currentDir
                currentDir=$(echo "$line" | sed 's/\//\\/g')
            fi
            if [[ $i -eq $n ]]
            then
                kill $!
                break
            fi
            ((i++))
        done < "$FIFO"
    done

}

function browse-cat () {
    serveur=$1
    port=$2
    archive=$3
    currentDir=$4
    fichier=$5
    
    echo "browse cat $archive $currentDir $fichier" | netcat "$serveur" "$port" > "$FIFO" &
    printResult
}

function browse-rm () {
    serveur=$1
    port=$2
    archive=$3
    currentDir=$4
    fichier=$5
    
    echo "browse rm $archive $currentDir $fichier" | netcat "$serveur" "$port" > "$FIFO" &
    printResult
}

function browse-touch () {
    serveur=$1
    port=$2
    archive=$3
    currentDir=$4
    fichier=$5
    
    echo "browse touch $archive $currentDir $fichier" | netcat "$serveur" "$port" > "$FIFO" &
    printResult
}

function browse-mkdir () {
    serveur=$1
    port=$2
    archive=$3
    currentDir=$4
    dossier=$5
    
    echo "browse mkdir $archive $currentDir $dossier" | netcat "$serveur" "$port" > "$FIFO" &
    printResult
}

function extract () {
    serveur=$1
    port=$2
    archive=$3
    echo "extract $archive" | netcat "$serveur" "$port" > "$FIFO" &
    file="archive.txt"
    printResult > "$file"

    if [[ !($(head -n 1 "$file") =~ ^[0-9]+:[0-9]+$) ]]
    then
        cat "$file"
        rm "$file"
        exit 0
    fi

    # On crée les fichiers header.txt et body.txt
    read line < "$file"
    beginHeader=$(echo $line | cut -d: -f1)
    beginBody=$(echo $line | cut -d: -f2)
    head -n $((beginBody-1)) "$file" | tail -n $((beginBody-beginHeader-1)) | sed 's/\\/\//g' > header.txt
    awk "NR>=$beginBody { print \$0 >> \"body.txt\" }" $file

    isInsideDirectory="false"
    directory=''
    while read line
    do
        if [[ $isInsideDirectory == "false" && "$line" =~ ^directory ]]
        then
            [[ $line != "directory" ]] && directory=$(echo $line | cut -d' ' -f2)
            isInsideDirectory="true"
            absolute="$PWD/$directory"
            absolute=${absolute//"//"/"/"}
            if [[ ! -d "$absolute" ]]
            then
                mkdir "$absolute"
                chmod u=$(echo $rights | cut -c2-4 | sed s/-//g),g=$(echo $rights | cut -c5-7 | sed s/-//g),o=$(echo $rights | cut -c8-10 | sed s/-//g) "$absolute"
            fi
        elif [[ $isInsideDirectory == "true" && "$line" == "@" ]]
        then
            directory=''
            isInsideDirectory="false"
        else
            read name rights size begin lines <<< $line
            absolute="$PWD/$directory/$name"
            absolute=${absolute//"//"/"/"}
            if [[ !($rights =~ ^d) ]]
            then
                touch "$absolute"
                if [[ -n $size ]]
                then
                    head -n $((begin+lines-1)) "body.txt" | tail -n "$lines" > "$absolute"
                fi
                chmod u=$(echo $rights | cut -c2-4 | sed s/-//g),g=$(echo $rights | cut -c5-7 | sed s/-//g),o=$(echo $rights | cut -c8-10 | sed s/-//g) "$absolute"
            fi
        fi
    done < header.txt
    rm body.txt header.txt $file
    echo "L'archive a été restaurée dans le répertoire courant."
    exit 0
}

if [[ 
    $# -eq 3 
    && "$1" == "-list" 
    && "$2" =~ $regexServeur 
    && "$3" =~ $regexPort
]]
then # list
    list "$2" "$3" "$4" 2>/dev/null
elif [[ 
    $# -eq 4
    && "$1" == "-create"
    && "$2" =~ $regexServeur 
    && "$3" =~ $regexPort
    && "$4" =~ $regexNomArchive
]]
then # create
    create "$2" "$3" "$4" 2>/dev/null
elif [[ 
    $# -eq 4
    && "$1" == "-browse"
    && "$2" =~ $regexServeur
    && "$3" =~ $regexPort
    && "$4" =~ $regexNomArchive
]]
then # browse
    serveur=$2
    port=$3
    archive=$4
    currentDir="\\"
    regexFichier="[[:alnum:]\\-_.]+"
    printf "vsh: %s < \e[31m%s\e[0m > " "$archive" "$currentDir"
    read -r line
    while [[ $line != "exit" ]]
    do
        if [[ $line == "pwd" ]]
        then
            echo $currentDir
        elif [[ $line == "ls" ]]
        then
            browse-ls "$2" "$3" "$4" "$currentDir" 2>/dev/null
        elif [[ $line =~ ^cd\ $regexFichier$ ]]
        then
            dossier=$(echo "$line" | sed 's/cd //g')
            browse-cd "$2" "$3" "$4" "$currentDir" "$dossier" 2>/dev/null

        elif [[ $line =~ ^cat\ $regexFichier$ ]]
        then
            fichier=$(echo "$line" | sed 's/cat //g')
            browse-cat "$2" "$3" "$4" "$currentDir" "$fichier" 2>/dev/null
        elif [[ $line =~ ^rm\ $regexFichier$ ]]
        then
            fichier=$(echo "$line" | sed 's/rm //g')
            browse-rm "$2" "$3" "$4" "$currentDir" "$fichier" 2>/dev/null
        elif [[ $line =~ ^touch\ $regexFichier$ ]]
        then
            fichier=$(echo "$line" | sed 's/touch //g')
            browse-touch "$2" "$3" "$4" "$currentDir" "$fichier" 2>/dev/null
        elif [[ $line =~ ^mkdir\ $regexFichier$ ]]
        then
            dossier=$(echo "$line" | sed 's/mkdir //g')
            browse-mkdir "$2" "$3" "$4" "$currentDir" "$dossier" 2>/dev/null
        else
            # prints correct usage
            printf "Usage :\n\tpwd\n\tls\n\tcd dossier\n\tcat fichier\n\trm fichier\n\ttouch fichier\n\tmkdir dossier\n"
        fi
        printf "vsh: %s < \e[31m%s\e[0m > " "$archive" "$currentDir"
        read -r line
    done

elif [[ 
    $# -eq 4
    && "$1" == "-extract"
    && "$2" =~ $regexServeur
    && "$3" =~ $regexPort
    && "$4" =~ $regexNomArchive
]]
then # extract
    extract "$2" "$3" "$4"
else
    cat << EOF
Usage :
    vsh -list    nom_serveur port
    vsh -create  nom_serveur port nom_archive
    vsh -browse  nom_serveur port nom_archive
    vsh -extract nom_serveur port nom_archive
EOF
fi

